# """Malware URL API."""

from flask import Flask, jsonify, request, make_response
from flask_restful import Resource, Api, reqparse, abort, fields, marshal_with
from flask_sqlalchemy import SQLAlchemy
from sqlalchemy import create_engine
from urllib.parse import urlparse
from flask_marshmallow import Marshmallow
import sqlite3
import os

# The GET requests would look like this:
# GET /v1/urlinfo/{resource_url_with_query_string}

app = Flask(__name__)
api = Api(app)
app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///malware.db'

db = SQLAlchemy(app)

class URLDatabase(db.Model):

    url = db.Column(db.String, primary_key=True)
    classification = db.Column(db.String)

    def __repr__(self):
        return f"URL_Lookup(url={url}, result={classification})"


# db.create_all()
# engine = create_engine('sqlite:///malware_urls.db')

URL_put_args = reqparse.RequestParser()
URL_put_args.add_argument('classification', type=str, help="Is the URL malware or valid?", required=True)

URL_update_args = reqparse.RequestParser()
URL_put_args.add_argument('classification', type=str, help="Is the URL malware or valid?")

resource_fields = {
    'url' : fields.String,
    'classification' : fields.String
}

class Lookup(Resource):
    @marshal_with(resource_fields)
    def get(self, subpath):
        result = URLDatabase.query.filter_by(url=subpath).first()
        if not result:
            abort(409, message = "could not find such a url")

        return result


        # return {'test': subpath.startswith('v1/urlinfo/'),
        # 'str':subpath}

        # if subpath.startswith('v1/urlinfo/'):
        #     url = subpath[11:]
        #     return {
        #         'url' : url,
        #         'result' : "Valid"
        #     }, 200
        # else:
        #     return {'result' : "Invalid Request"}
    
    @marshal_with(resource_fields)
    def put(self, subpath):
        args = URL_put_args.parse_args()
        result = URLDatabase.query.filter_by(url=subpath).first()
        if result:
            abort(409, message = "url already exists")

        input = URLDatabase(url=subpath, classification=args['classification'])
        db.session.add(input)
        db.session.commit()
        return input

    @marshal_with(resource_fields)
    def patch(self, subpath):
        args = URL_update_args.parse_args()
        result = URLDatabase.query.filter_by(url=subpath).first()
        if not result:
            abort(404, message="url doesn't exist, cannot update")

        if args['classification']:
            result.classification = args['classification']
            
        db.session.commit()
        return result

    # def delete(self, subpath):
    #     result = URLDatabase.query.filter_by(url=subpath).first()
    #     if result:
    #         abort(404, message="url doesn't exist, cannot delete")
        
    #     db.session.delete(result)
    #     db.session.commit()
    #     return result

api.add_resource(Lookup, '/<path:subpath>')

if __name__ == '__main__':
    app.run(debug=True)


# @app.route('/')
# def lookup():
# @app.route('/v1/urlinfo/<path:subpath>', methods=['GET'])
# def lookup(subpath):
#     return "Hello World!"